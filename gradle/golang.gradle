task installProtocGenGo(type: Exec) {
  onlyIf {
    pathOfExecutable("protoc-gen-go") == ""
  }
  commandLine "go", "get", "github.com/golang/protobuf/protoc-gen-go"
}

task generateProtoGo {
  dependsOn "installProtocGenGo"
  ext {
    source = "${protoGenMainDir}/go"
  }
  inputs.file "mod.go"
  inputs.file "lib.go"
  inputs.dir "proto"
  outputs.dir source
  doLast {
    mkdir source
    fileTree("proto"){ include "**/*.proto" }.visit { fd ->
      if (fd.file.directory) return
      exec {
        commandLine "protoc", "-Iproto", "--go_out=plugins=grpc:${source}", fd.path
      }
    }
    copy {
      from "lib.go"
      into source
    }
    exec {
      environment buildEnviron(dist)
      standardInput file("mod.go").newInputStream()
      standardOutput file("${source}/go.mod").newOutputStream()
      commandLine "envsubst"
    }
    fileTree(source){ include "*", "github.com/*" }.visit { fd ->
      if (fd.file.file) return
      if (fd.path == "github.com") return
      copy {
        from "${source}/go.mod"
        into "${source}/${fd.path}"
        filter { line ->
          line.startsWith("module") ? "module ${fd.path}" : line
        }
      }
    }
  }
}

task golang(type: Exec) {
  dependsOn "generateProtoGo"
  inputs.dir generateProtoGo.source
  outputs.dir generateProtoGo.source
  workingDir generateProtoGo.source
  commandLine "go", "build"
  args(dist.build == "release" ? ["-ldflags", "-s -w"] : [])
  args "./..."
}

task __golang__ {
  dependsOn "golang"
  ext {
    src = "go"
  }
  inputs.dir generateProtoGo.source
  outputs.dir src
  doLast {
    copy {
      from generateProtoGo.source
      exclude "go.sum", "go.mod"
      into src
    }
    copy {
      from "${generateProtoGo.source}/go.mod"
      into src
      filter { line ->
        line.startsWith("module") ? (line + "/go") : line
      }
    }
  }
}
